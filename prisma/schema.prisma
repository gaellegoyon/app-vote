datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

model Voter {
    id             String          @id @default(cuid())
    email          String          @unique
    pwdHash        String?
    invitedAt      DateTime?
    votedAt        DateTime?
    createdAt      DateTime        @default(now())
    isActive       Boolean         @default(false)
    password       String?
    electionVoters ElectionVoter[]
}

model ElectionVoter {
    id         String    @id @default(cuid())
    electionId String
    voterId    String
    invitedAt  DateTime  @default(now())
    votedAt    DateTime?
    election   Election  @relation(fields: [electionId], references: [id], onDelete: Cascade)
    voter      Voter     @relation(fields: [voterId], references: [id], onDelete: Cascade)

    @@unique([electionId, voterId])
}

model Candidate {
    id         String   @id @default(cuid())
    name       String
    slogan     String?
    program    String?
    validated  Boolean  @default(false)
    electionId String
    election   Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
    createdAt  DateTime @default(now())
}

model Election {
    id              String          @id @default(cuid())
    title           String
    round           Int             @default(1)
    numberOfElected Int             @default(1) // Nombre d'élus à déterminer
    opensAt         DateTime
    closesAt        DateTime
    parentId        String? // ID de l'élection du tour précédent
    parent          Election?       @relation("ElectionRounds", fields: [parentId], references: [id])
    childElections  Election[]      @relation("ElectionRounds")
    status          ElectionStatus  @default(CREATED)
    candidates      Candidate[]
    electionVoters  ElectionVoter[]
    inviteTokens    InviteToken[]
    createdAt       DateTime        @default(now())
}

enum ElectionStatus {
    CREATED // Élection créée mais pas encore ouverte
    OPEN // Élection en cours
    CLOSED // Élection fermée, dépouillement en cours
    COMPLETED // Résultats finalisés
    RUNOFF_REQUIRED // Second tour nécessaire
}

model Ballot {
    id          String   @id @default(cuid())
    electionId  String
    candidateId String
    voterPseudo String
    payloadEnc  Bytes
    createdAt   DateTime @default(now())
}

model EventLog {
    id    String   @id @default(cuid())
    type  String
    actor String?
    meta  Json?
    ts    DateTime @default(now())
}

model AdminUser {
    id         String   @id @default(cuid())
    email      String   @unique
    ldapUid    String   @unique // uid dans LDAP (ex: admin1)
    role       String   @default("admin")
    totpSecret String?
    isActive   Boolean  @default(true)
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt
}

model AuditLog {
    id        String   @id @default(cuid())
    email     String? // Email de l'utilisateur (null pour actions anonymes)
    action    String // Action effectuée (login, logout, vote, etc.)
    resource  String? // Ressource affectée
    ip        String? // Adresse IP source
    userAgent String? // User-Agent du navigateur
    status    String   @default("success") // success, failure, error
    details   Json? // Données additionnelles
    timestamp DateTime @default(now())

    @@index([email])
    @@index([timestamp])
}

model InviteToken {
    id                String   @id @default(cuid())
    email             String
    electionId        String
    election          Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
    jti               String   @unique
    used              Boolean  @default(false)
    expiresAt         DateTime
    createdAt         DateTime @default(now())
    temporaryPassword String?
}
